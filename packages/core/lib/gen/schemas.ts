/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */
import { z } from 'zod'

export const apiErrorSchema = z.object({
  code: z.lazy(() => apiErrorCodeSchema),
  message: z.string(),
})

export const apiErrorCodeSchema = z.enum([
  'NOT_AUTHENTICATED',
  'NOT_AUTHORIZED',
  'NOT_FOUND',
  'ALREADY_EXISTS',
  'VALIDATION',
  'BAD_GATEWAY',
  'UNKNOWN',
])

/**
 * @description Long-lived token linked to a user\'s account. Useful for third party client apps to access a user\'s data. The full value is returned only once, on creation.
 */
export const apiKeySchema = z
  .object({
    id: z.string().uuid().describe('Unique identifier of the API key'),
    title: z.string().describe('Human-readable name of the API key'),
    preview: z
      .string()
      .describe(
        'Partial view of the API key value for identification purposes',
      ),
    createdAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the API key was created'),
    updatedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the API key was last modified'),
  })
  .describe(
    "Long-lived token linked to a user's account. Useful for third party client apps to access a user's data. The full value is returned only once, on creation.",
  )

/**
 * @description Data to create a new API key
 */
export const apiKeyCreateSchema = z
  .object({
    title: z
      .string()
      .min(1)
      .describe(
        'Human-readable name for the API key to create, cannot be empty',
      ),
  })
  .describe('Data to create a new API key')

/**
 * @description Newly created API key, containing the full value. This value must be saved in a safe location, as subsequent GET requests will only show a preview.
 */
export const apiKeyCreatedSchema = z
  .object({
    id: z.string().uuid().describe('Unique identifier of the new API key'),
    value: z.string().describe('Full value of the new API key'),
    title: z.string().describe('Human-readable name of the new API key'),
    createdAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the API key was created'),
  })
  .describe(
    'Newly created API key, containing the full value. This value must be saved in a safe location, as subsequent GET requests will only show a preview.',
  )

/**
 * @description Details regarding the existing API key to update
 */
export const apiKeyUpdateSchema = z
  .object({
    title: z
      .string()
      .min(1)
      .describe(
        'Human-readable name for the API key to update, cannot be empty',
      )
      .optional(),
  })
  .describe('Details regarding the existing API key to update')

/**
 * @description Bookmark to a webpage
 */
export const bookmarkSchema = z
  .object({
    id: z.string().uuid().describe('Unique identifier of the bookmark'),
    link: z.string().url().describe('URL of the webpage the bookmark links to'),
    title: z.string().describe('Title of the bookmark'),
    thumbnailUrl: z
      .string()
      .url()
      .describe('Thumbnail URL of the bookmark')
      .nullable(),
    publishedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the bookmark was published')
      .nullable(),
    author: z.string().describe('Author of the bookmark').nullable(),
    archivedUrl: z
      .string()
      .url()
      .describe("URL of the archived version of the bookmark's thumbnail")
      .nullable(),
    createdAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the bookmark was created'),
    updatedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the bookmark was modified'),
  })
  .describe('Bookmark to a webpage')

/**
 * @description Data to create a new bookmark
 */
export const bookmarkCreateSchema = z
  .object({
    url: z.string().url().describe('URL of the webpage the bookmark links to'),
    title: z
      .string()
      .min(1)
      .describe('Human-readable name for the new bookmark, cannot be empty'),
    thumbnailUrl: z
      .string()
      .url()
      .describe('Thumbnail URL of the new bookmark, will be archived')
      .optional()
      .nullable(),
    publishedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the bookmark was published')
      .optional()
      .nullable(),
    author: z
      .string()
      .min(1)
      .describe('Author for the new bookmark, cannot be empty')
      .optional()
      .nullable(),
  })
  .describe('Data to create a new bookmark')

export const bookmarkDateFieldSchema = z.enum([
  'publishedAt',
  'createdAt',
  'updatedAt',
])

/**
 * @description Extended details of a bookmark
 */
export const bookmarkDetailsSchema = z
  .object({
    bookmark: z.lazy(() => bookmarkSchema).describe('Bookmark to a webpage'),
    tags: z
      .array(
        z
          .lazy(() => tagSchema)
          .describe('Tag that can be attached to subscriptions and bookmarks'),
      )
      .describe('Linked tags, present if requested')
      .optional(),
  })
  .describe('Extended details of a bookmark')

export const bookmarkFilterSchema = z.union([
  z.object({
    text: z.object({
      field: z.lazy(() => bookmarkTextFieldSchema),
      op: z.lazy(() => textOpSchema),
    }),
  }),
  z.object({
    date: z.object({
      field: z.lazy(() => bookmarkDateFieldSchema),
      op: z.lazy(() => dateOpSchema),
    }),
  }),
  z.object({
    and: z.array(z.lazy(() => bookmarkFilterSchema)),
  }),
  z.object({
    or: z.array(z.lazy(() => bookmarkFilterSchema)),
  }),
  z.object({
    not: z.lazy(() => bookmarkFilterSchema),
  }),
])

/**
 * @description Data to scrape a bookmark using
 */
export const bookmarkScrapeSchema = z
  .object({
    url: z.string().url().describe('URL of a webpage to scrape'),
  })
  .describe('Data to scrape a bookmark using')

/**
 * @description Scraped bookmark
 */
export const bookmarkScrapedSchema = z
  .object({
    link: z
      .string()
      .url()
      .describe('URL of the webpage of the scraped bookmark'),
    title: z.string().describe('Title of the scraped bookmark'),
    thumbnailUrl: z
      .string()
      .url()
      .describe('Thumbnail URL of the scraped bookmark')
      .nullable(),
    publishedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the scraped bookmark was published')
      .nullable(),
    author: z.string().describe('Author of the scraped bookmark').nullable(),
  })
  .describe('Scraped bookmark')

export const bookmarkTextFieldSchema = z.enum([
  'link',
  'title',
  'author',
  'tag',
])

/**
 * @description Updates to make to an existing bookmark
 */
export const bookmarkUpdateSchema = z
  .object({
    title: z
      .string()
      .min(1)
      .describe(
        'Human-readable name for the bookmark to update, cannot be empty',
      )
      .optional(),
    thumbnailUrl: z
      .string()
      .url()
      .describe('Thumbnail URL of the bookmark to update, will be archived')
      .optional()
      .nullable(),
    publishedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the bookmark was published')
      .optional()
      .nullable(),
    author: z
      .string()
      .min(1)
      .describe('Author of the bookmark to update, cannot be empty')
      .optional()
      .nullable(),
  })
  .describe('Updates to make to an existing bookmark')

export const booleanOpSchema = z.object({
  equals: z.boolean(),
})

export const codePayloadSchema = z.object({
  code: z.string(),
  codeVerifier: z.string(),
  nonce: z.string(),
})

export const collectionSchema = z.object({
  id: z.string().uuid(),
  title: z.string(),
  filter: z.lazy(() => bookmarkFilterSchema),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

export const collectionCreateSchema = z.object({
  title: z.string().min(1),
  filter: z.lazy(() => bookmarkFilterSchema),
})

export const collectionUpdateSchema = z.object({
  title: z.string().min(1).optional(),
  filter: z.union([z.lazy(() => bookmarkFilterSchema), z.null()]).optional(),
})

/**
 * @description API config
 */
export const configSchema = z
  .object({
    oidc: z
      .lazy(() => oidcConfigSchema)
      .describe('API OIDC config')
      .optional(),
    storage: z.lazy(() => storageConfigSchema).describe('API storage config'),
  })
  .describe('API config')

export const dateOpSchema = z.union([
  z.object({
    before: z.string().datetime(),
  }),
  z.object({
    after: z.string().datetime(),
  }),
  z.object({
    between: z.object({
      start: z.string().datetime(),
      end: z.string().datetime(),
    }),
  }),
  z.object({
    inLast: z.number().int(),
  }),
])

/**
 * @description RSS feed
 */
export const feedSchema = z
  .object({
    id: z.string().uuid().describe('Unique identifier of the feed'),
    sourceUrl: z.string().url().describe('URL to scrape for feed updates'),
    link: z.string().url().describe('URL of the webpage the feed links to'),
    title: z.string().describe('Title of the feed'),
    description: z.string().describe('Description of the feed').nullable(),
    refreshedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the feed was refreshed')
      .nullable(),
    isCustom: z
      .boolean()
      .describe('Whether the feed was scraped from a custom plugin'),
  })
  .describe('RSS feed')

/**
 * @description Data to detect RSS feeds using
 */
export const feedDetectSchema = z
  .object({
    url: z.string().url().describe('URL of a webpage to detect RSS feeds on'),
  })
  .describe('Data to detect RSS feeds using')

/**
 * @description Detected RSS feed
 */
export const feedDetectedSchema = z
  .object({
    url: z.string().url().describe('URL of the detected RSS feed'),
    title: z.string().describe('Title of the detected RSS feed'),
  })
  .describe('Detected RSS feed')

/**
 * @description RSS feed entry
 */
export const feedEntrySchema = z
  .object({
    id: z.string().uuid().describe('Unique identifier of the feed entry'),
    link: z
      .string()
      .url()
      .describe('URL of the webpage the feed entry links to'),
    title: z.string().describe('Title of the feed entry'),
    publishedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the feed entry was published'),
    description: z
      .string()
      .describe('Description of the feed entry')
      .nullable(),
    author: z.string().describe('Author of the feed entry').nullable(),
    thumbnailUrl: z
      .string()
      .url()
      .describe('Thumbnail URL of the feed entry')
      .nullable(),
    feedId: z
      .string()
      .uuid()
      .describe('Unique identifier of the associated RSS feed'),
  })
  .describe('RSS feed entry')

/**
 * @description Data to scrape an RSS feed using
 */
export const feedScrapeSchema = z
  .object({
    url: z.string().url().describe('URL of an RSS feed to scrape'),
  })
  .describe('Data to scrape an RSS feed using')

/**
 * @description Action to link tags to a bookmark
 */
export const linkBookmarkTagsSchema = z
  .object({
    tagIds: z
      .array(z.string().uuid())
      .describe('Unique identifiers of the tags to link to the bookmark'),
  })
  .describe('Action to link tags to a bookmark')

/**
 * @description Action to link tags to a user subscription
 */
export const linkSubscriptionTagsSchema = z
  .object({
    tagIds: z
      .array(z.string().uuid())
      .describe('Unique identifiers of the tags to link to the subscription'),
  })
  .describe('Action to link tags to a user subscription')

export const loginPayloadSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
})

/**
 * @description API OIDC config
 */
export const oidcConfigSchema = z
  .object({
    clientId: z.string().describe('OIDC client ID'),
    issuer: z.string().url().describe('OIDC issuer URL'),
    redirectUri: z.string().url().describe('OIDC redirect URI'),
  })
  .describe('API OIDC config')

/**
 * @description Paginated list of results
 */
export const paginatedApiKeySchema = z
  .object({
    data: z
      .array(
        z
          .object({
            id: z.string().uuid().describe('Unique identifier of the API key'),
            title: z.string().describe('Human-readable name of the API key'),
            preview: z
              .string()
              .describe(
                'Partial view of the API key value for identification purposes',
              ),
            createdAt: z
              .string()
              .datetime()
              .describe('Timestamp at which the API key was created'),
            updatedAt: z
              .string()
              .datetime()
              .describe('Timestamp at which the API key was last modified'),
          })
          .describe(
            "Long-lived token linked to a user's account. Useful for third party client apps to access a user's data. The full value is returned only once, on creation.",
          ),
      )
      .describe('Current set of results'),
    cursor: z
      .string()
      .describe('Pagination cursor, only present if more results are available')
      .optional(),
  })
  .describe('Paginated list of results')

/**
 * @description Paginated list of results
 */
export const paginatedBookmarkDetailsSchema = z
  .object({
    data: z
      .array(
        z
          .object({
            bookmark: z
              .lazy(() => bookmarkSchema)
              .describe('Bookmark to a webpage'),
            tags: z
              .array(
                z
                  .lazy(() => tagSchema)
                  .describe(
                    'Tag that can be attached to subscriptions and bookmarks',
                  ),
              )
              .describe('Linked tags, present if requested')
              .optional(),
          })
          .describe('Extended details of a bookmark'),
      )
      .describe('Current set of results'),
    cursor: z
      .string()
      .describe('Pagination cursor, only present if more results are available')
      .optional(),
  })
  .describe('Paginated list of results')

/**
 * @description Paginated list of results
 */
export const paginatedCollectionSchema = z
  .object({
    data: z
      .array(
        z.object({
          id: z.string().uuid(),
          title: z.string(),
          filter: z.lazy(() => bookmarkFilterSchema),
          createdAt: z.string().datetime(),
          updatedAt: z.string().datetime(),
        }),
      )
      .describe('Current set of results'),
    cursor: z
      .string()
      .describe('Pagination cursor, only present if more results are available')
      .optional(),
  })
  .describe('Paginated list of results')

/**
 * @description Paginated list of results
 */
export const paginatedFeedEntrySchema = z
  .object({
    data: z
      .array(
        z
          .object({
            id: z
              .string()
              .uuid()
              .describe('Unique identifier of the feed entry'),
            link: z
              .string()
              .url()
              .describe('URL of the webpage the feed entry links to'),
            title: z.string().describe('Title of the feed entry'),
            publishedAt: z
              .string()
              .datetime()
              .describe('Timestamp at which the feed entry was published'),
            description: z
              .string()
              .describe('Description of the feed entry')
              .nullable(),
            author: z.string().describe('Author of the feed entry').nullable(),
            thumbnailUrl: z
              .string()
              .url()
              .describe('Thumbnail URL of the feed entry')
              .nullable(),
            feedId: z
              .string()
              .uuid()
              .describe('Unique identifier of the associated RSS feed'),
          })
          .describe('RSS feed entry'),
      )
      .describe('Current set of results'),
    cursor: z
      .string()
      .describe('Pagination cursor, only present if more results are available')
      .optional(),
  })
  .describe('Paginated list of results')

/**
 * @description Paginated list of results
 */
export const paginatedStreamSchema = z
  .object({
    data: z
      .array(
        z.object({
          id: z.string().uuid(),
          title: z.string(),
          filter: z.lazy(() => subscriptionEntryFilterSchema),
          createdAt: z.string().datetime(),
          updatedAt: z.string().datetime(),
        }),
      )
      .describe('Current set of results'),
    cursor: z
      .string()
      .describe('Pagination cursor, only present if more results are available')
      .optional(),
  })
  .describe('Paginated list of results')

/**
 * @description Paginated list of results
 */
export const paginatedSubscriptionDetailsSchema = z
  .object({
    data: z
      .array(
        z
          .object({
            subscription: z
              .lazy(() => subscriptionSchema)
              .describe('User subscription to an RSS feed'),
            feed: z
              .lazy(() => feedSchema)
              .describe('RSS feed')
              .optional(),
            tags: z
              .array(
                z
                  .lazy(() => tagSchema)
                  .describe(
                    'Tag that can be attached to subscriptions and bookmarks',
                  ),
              )
              .describe('Linked tags, present if requested')
              .optional(),
            unreadCount: z
              .number()
              .int()
              .describe(
                'Count of unread subscription entries associated with the subscription, present if requested',
              )
              .optional(),
          })
          .describe('Extended details of a user subscription'),
      )
      .describe('Current set of results'),
    cursor: z
      .string()
      .describe('Pagination cursor, only present if more results are available')
      .optional(),
  })
  .describe('Paginated list of results')

/**
 * @description Paginated list of results
 */
export const paginatedSubscriptionEntryDetailsSchema = z
  .object({
    data: z
      .array(
        z
          .object({
            subscriptionEntry: z
              .lazy(() => subscriptionEntrySchema)
              .describe(
                'Association of a RSS feed entry to a user subscription. The pairing of subscription ID and feed entry ID is unique.',
              ),
            feedEntry: z
              .lazy(() => feedEntrySchema)
              .describe('RSS feed entry')
              .optional(),
          })
          .describe('Extended details of a subscription entry'),
      )
      .describe('Current set of results'),
    cursor: z
      .string()
      .describe('Pagination cursor, only present if more results are available')
      .optional(),
  })
  .describe('Paginated list of results')

/**
 * @description Paginated list of results
 */
export const paginatedTagDetailsSchema = z
  .object({
    data: z
      .array(
        z
          .object({
            tag: z
              .lazy(() => tagSchema)
              .describe(
                'Tag that can be attached to subscriptions and bookmarks',
              ),
            subscriptionCount: z
              .number()
              .int()
              .describe(
                'Count of subscriptions the tag is linked to, present if requested',
              )
              .optional(),
            bookmarkCount: z
              .number()
              .int()
              .describe(
                'Count of bookmarks the tag is linked to, present if requested',
              )
              .optional(),
          })
          .describe('Extended details of a tag'),
      )
      .describe('Current set of results'),
    cursor: z
      .string()
      .describe('Pagination cursor, only present if more results are available')
      .optional(),
  })
  .describe('Paginated list of results')

export const registerPayloadSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
  displayName: z.string().min(1).optional().nullable(),
  imageUrl: z.string().url().optional().nullable(),
})

/**
 * @description API storage config
 */
export const storageConfigSchema = z
  .object({
    baseUrl: z.string().url().describe('Base URL for the image storage server'),
  })
  .describe('API storage config')

export const streamSchema = z.object({
  id: z.string().uuid(),
  title: z.string(),
  filter: z.lazy(() => subscriptionEntryFilterSchema),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})

export const streamCreateSchema = z.object({
  title: z.string().min(1),
  filter: z.lazy(() => subscriptionEntryFilterSchema),
})

export const streamUpdateSchema = z.object({
  title: z.string().min(1).optional(),
  filter: z
    .union([z.lazy(() => subscriptionEntryFilterSchema), z.null()])
    .optional(),
})

/**
 * @description User subscription to an RSS feed
 */
export const subscriptionSchema = z
  .object({
    id: z.string().uuid().describe('Unique identifier of the subscription'),
    title: z.string().describe('Human-readable name of the subscription'),
    description: z
      .string()
      .describe('Description of the subscription')
      .nullable(),
    feedId: z
      .string()
      .uuid()
      .describe('Unique identifier of the associated RSS feed'),
    createdAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the subscription was created'),
    updatedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the subscription was modified'),
  })
  .describe('User subscription to an RSS feed')

/**
 * @description Data to create a new user subscription
 */
export const subscriptionCreateSchema = z
  .object({
    title: z
      .string()
      .min(1)
      .describe(
        'Human-readable name for the new subscription, cannot be empty',
      ),
    description: z
      .string()
      .min(1)
      .describe('Description for the new subscription, cannot be empty')
      .optional()
      .nullable(),
    feedId: z
      .string()
      .uuid()
      .describe('Unique identifier of the associated RSS feed'),
  })
  .describe('Data to create a new user subscription')

/**
 * @description Extended details of a user subscription
 */
export const subscriptionDetailsSchema = z
  .object({
    subscription: z
      .lazy(() => subscriptionSchema)
      .describe('User subscription to an RSS feed'),
    feed: z
      .lazy(() => feedSchema)
      .describe('RSS feed')
      .optional(),
    tags: z
      .array(
        z
          .lazy(() => tagSchema)
          .describe('Tag that can be attached to subscriptions and bookmarks'),
      )
      .describe('Linked tags, present if requested')
      .optional(),
    unreadCount: z
      .number()
      .int()
      .describe(
        'Count of unread subscription entries associated with the subscription, present if requested',
      )
      .optional(),
  })
  .describe('Extended details of a user subscription')

/**
 * @description Association of a RSS feed entry to a user subscription. The pairing of subscription ID and feed entry ID is unique.
 */
export const subscriptionEntrySchema = z
  .object({
    subscriptionId: z
      .string()
      .uuid()
      .describe('Unique identifier of the associated subscription'),
    feedEntryId: z
      .string()
      .uuid()
      .describe('Unique identifier of the associated feed entry'),
    hasRead: z
      .boolean()
      .describe('Whether the subscription entry has been marked as read'),
    readAt: z
      .string()
      .datetime()
      .describe(
        'Timestamp at which the subscription entry has been marked as read',
      )
      .optional()
      .nullable(),
  })
  .describe(
    'Association of a RSS feed entry to a user subscription. The pairing of subscription ID and feed entry ID is unique.',
  )

export const subscriptionEntryBooleanFieldSchema = z.enum(['hasRead'])

export const subscriptionEntryDateFieldSchema = z.enum(['publishedAt'])

/**
 * @description Extended details of a subscription entry
 */
export const subscriptionEntryDetailsSchema = z
  .object({
    subscriptionEntry: z
      .lazy(() => subscriptionEntrySchema)
      .describe(
        'Association of a RSS feed entry to a user subscription. The pairing of subscription ID and feed entry ID is unique.',
      ),
    feedEntry: z
      .lazy(() => feedEntrySchema)
      .describe('RSS feed entry')
      .optional(),
  })
  .describe('Extended details of a subscription entry')

export const subscriptionEntryFilterSchema = z.union([
  z.object({
    text: z.object({
      field: z.lazy(() => subscriptionEntryTextFieldSchema),
      op: z.lazy(() => textOpSchema),
    }),
  }),
  z.object({
    boolean: z.object({
      field: z.lazy(() => subscriptionEntryBooleanFieldSchema),
      op: z.lazy(() => booleanOpSchema),
    }),
  }),
  z.object({
    date: z.object({
      field: z.lazy(() => subscriptionEntryDateFieldSchema),
      op: z.lazy(() => dateOpSchema),
    }),
  }),
  z.object({
    and: z.array(z.lazy(() => subscriptionEntryFilterSchema)),
  }),
  z.object({
    or: z.array(z.lazy(() => subscriptionEntryFilterSchema)),
  }),
  z.object({
    not: z.lazy(() => subscriptionEntryFilterSchema),
  }),
])

export const subscriptionEntryTextFieldSchema = z.enum([
  'link',
  'title',
  'description',
  'author',
  'tag',
])

/**
 * @description Updates to make to an existing subscription
 */
export const subscriptionUpdateSchema = z
  .object({
    title: z
      .string()
      .min(1)
      .describe(
        'Human-readable name for the subscription to update, cannot be empty',
      )
      .optional()
      .nullable(),
    description: z
      .string()
      .min(1)
      .describe('Description for the subscription to update, cannot be empty')
      .optional()
      .nullable(),
  })
  .describe('Updates to make to an existing subscription')

/**
 * @description Tag that can be attached to subscriptions and bookmarks
 */
export const tagSchema = z
  .object({
    id: z.string().uuid().describe('Unique identifier of the tag'),
    title: z
      .string()
      .describe('Human-readable name of the tag, unique per user'),
    createdAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the tag was created'),
    updatedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the tag was last modified'),
  })
  .describe('Tag that can be attached to subscriptions and bookmarks')

/**
 * @description Data to create a new tag
 */
export const tagCreateSchema = z
  .object({
    title: z
      .string()
      .min(1)
      .describe('Human-readable name for the new tag, cannot be empty'),
  })
  .describe('Data to create a new tag')

/**
 * @description Extended details of a tag
 */
export const tagDetailsSchema = z
  .object({
    tag: z
      .lazy(() => tagSchema)
      .describe('Tag that can be attached to subscriptions and bookmarks'),
    subscriptionCount: z
      .number()
      .int()
      .describe(
        'Count of subscriptions the tag is linked to, present if requested',
      )
      .optional(),
    bookmarkCount: z
      .number()
      .int()
      .describe('Count of bookmarks the tag is linked to, present if requested')
      .optional(),
  })
  .describe('Extended details of a tag')

/**
 * @description Updates to make to an existing tag
 */
export const tagUpdateSchema = z
  .object({
    title: z
      .string()
      .min(1)
      .describe('Human-readable name for the tag to update, cannot be empty')
      .optional(),
  })
  .describe('Updates to make to an existing tag')

export const textOpSchema = z.union([
  z.object({
    equals: z.string(),
  }),
  z.object({
    contains: z.string(),
  }),
  z.object({
    startsWith: z.string(),
  }),
  z.object({
    endsWith: z.string(),
  }),
])

export const tokenDataSchema = z.object({
  accessToken: z.string(),
  tokenType: z.lazy(() => tokenTypeSchema),
  expiresIn: z.number().int(),
})

export const tokenTypeSchema = z.enum(['bearer'])

/**
 * @description User account. Supports email/password and OIDC.
 */
export const userSchema = z
  .object({
    id: z.string().uuid().describe('Unique identifier of the user'),
    email: z.string().email().describe('Email address of the user'),
    displayName: z.string().nullable(),
    imageUrl: z.string().url().nullable(),
    createdAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the user was created'),
    updatedAt: z
      .string()
      .datetime()
      .describe('Timestamp at which the user was last modified'),
  })
  .describe('User account. Supports email/password and OIDC.')

/**
 * @description Paginated list of API keys
 */
export const listApiKeys200Schema = z
  .lazy(() => paginatedApiKeySchema)
  .describe('Paginated list of results')

/**
 * @description User not authenticated
 */
export const listApiKeys401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const listApiKeysErrorSchema = z.lazy(() => apiErrorSchema)

export const listApiKeysQueryResponseSchema = z.lazy(() => listApiKeys200Schema)

/**
 * @description Created API key
 */
export const createApiKey201Schema = z
  .lazy(() => apiKeyCreatedSchema)
  .describe(
    'Newly created API key, containing the full value. This value must be saved in a safe location, as subsequent GET requests will only show a preview.',
  )

/**
 * @description User not authenticated
 */
export const createApiKey401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const createApiKey422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const createApiKeyErrorSchema = z.lazy(() => apiErrorSchema)

export const createApiKeyMutationRequestSchema = z
  .lazy(() => apiKeyCreateSchema)
  .describe('Data to create a new API key')

export const createApiKeyMutationResponseSchema = z.lazy(
  () => createApiKey201Schema,
)

export const getApiKeyPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description API key by ID
 */
export const getApiKey200Schema = z
  .lazy(() => apiKeySchema)
  .describe(
    "Long-lived token linked to a user's account. Useful for third party client apps to access a user's data. The full value is returned only once, on creation.",
  )

/**
 * @description User not authenticated
 */
export const getApiKey401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const getApiKey403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description API key not found
 */
export const getApiKey404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const getApiKeyErrorSchema = z.lazy(() => apiErrorSchema)

export const getApiKeyQueryResponseSchema = z.lazy(() => getApiKey200Schema)

export const deleteApiKeyPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Successfully deleted API key
 */
export const deleteApiKey204Schema = z.any()

/**
 * @description User not authenticated
 */
export const deleteApiKey401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const deleteApiKey403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description API key not found
 */
export const deleteApiKey404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const deleteApiKeyErrorSchema = z.lazy(() => apiErrorSchema)

export const deleteApiKeyMutationResponseSchema = z.lazy(
  () => deleteApiKey204Schema,
)

export const updateApiKeyPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Updated API key
 */
export const updateApiKey200Schema = z
  .lazy(() => apiKeySchema)
  .describe(
    "Long-lived token linked to a user's account. Useful for third party client apps to access a user's data. The full value is returned only once, on creation.",
  )

/**
 * @description User not authenticated
 */
export const updateApiKey401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const updateApiKey403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description API key not found
 */
export const updateApiKey404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const updateApiKey422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const updateApiKeyErrorSchema = z.lazy(() => apiErrorSchema)

export const updateApiKeyMutationRequestSchema = z
  .lazy(() => apiKeyUpdateSchema)
  .describe('Details regarding the existing API key to update')

export const updateApiKeyMutationResponseSchema = z.lazy(
  () => updateApiKey200Schema,
)

/**
 * @description Created user
 */
export const registerUser200Schema = z
  .lazy(() => userSchema)
  .describe('User account. Supports email/password and OIDC.')

/**
 * @description Email already registered
 */
export const registerUser409Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const registerUser422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const registerUserErrorSchema = z.lazy(() => apiErrorSchema)

export const registerUserMutationRequestSchema = z.lazy(
  () => registerPayloadSchema,
)

export const registerUserMutationResponseSchema = z.lazy(
  () => registerUser200Schema,
)

/**
 * @description Access token for autheticated user
 */
export const loginUser200Schema = z.lazy(() => tokenDataSchema)

/**
 * @description Bad credentials
 */
export const loginUser401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const loginUser422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const loginUserErrorSchema = z.lazy(() => apiErrorSchema)

export const loginUserMutationRequestSchema = z.lazy(() => loginPayloadSchema)

export const loginUserMutationResponseSchema = z.lazy(() => loginUser200Schema)

/**
 * @description Active user
 */
export const getActiveUser200Schema = z
  .lazy(() => userSchema)
  .describe('User account. Supports email/password and OIDC.')

/**
 * @description User not authenticated
 */
export const getActiveUser401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const getActiveUserErrorSchema = z.lazy(() => apiErrorSchema)

export const getActiveUserQueryResponseSchema = z.lazy(
  () => getActiveUser200Schema,
)

/**
 * @description Access token for autheticated user
 */
export const refreshToken200Schema = z.lazy(() => tokenDataSchema)

/**
 * @description User not authenticated
 */
export const refreshToken401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const refreshToken422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const refreshTokenErrorSchema = z.lazy(() => apiErrorSchema)

export const refreshTokenMutationResponseSchema = z.lazy(
  () => refreshToken200Schema,
)

/**
 * @description Successfully logged out
 */
export const logoutUser204Schema = z.any()

/**
 * @description User not authenticated
 */
export const logoutUser401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const logoutUserErrorSchema = z.lazy(() => apiErrorSchema)

export const logoutUserMutationResponseSchema = z.lazy(
  () => logoutUser204Schema,
)

/**
 * @description Access token for autheticated user
 */
export const exchangeCode200Schema = z.lazy(() => tokenDataSchema)

/**
 * @description Bad credentials
 */
export const exchangeCode401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const exchangeCode422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const exchangeCodeErrorSchema = z.lazy(() => apiErrorSchema)

export const exchangeCodeMutationRequestSchema = z.lazy(() => codePayloadSchema)

export const exchangeCodeMutationResponseSchema = z.lazy(
  () => exchangeCode200Schema,
)

export const listBookmarksQueryParamsSchema = z
  .object({
    collectionId: z
      .string()
      .uuid()
      .describe(
        'Filter by the ID of a collection whose filters may apply to the bookmark',
      )
      .optional(),
    filterByTags: z
      .boolean()
      .describe('Whether to filter by tags linked to the bookmark')
      .optional(),
    'tag[]': z
      .array(z.string().uuid())
      .describe('Filter by the IDs of the tags linked to the bookmark')
      .optional(),
    cursor: z.string().describe('Pagination cursor').optional(),
    withTags: z
      .boolean()
      .describe('Whether to include the tags linked to the bookmark')
      .optional(),
  })
  .optional()

/**
 * @description Paginated list of bookmarks
 */
export const listBookmarks200Schema = z
  .lazy(() => paginatedBookmarkDetailsSchema)
  .describe('Paginated list of results')

/**
 * @description User not authenticated
 */
export const listBookmarks401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const listBookmarksErrorSchema = z.lazy(() => apiErrorSchema)

export const listBookmarksQueryResponseSchema = z.lazy(
  () => listBookmarks200Schema,
)

/**
 * @description Created bookmark
 */
export const createBookmark201Schema = z
  .lazy(() => bookmarkSchema)
  .describe('Bookmark to a webpage')

/**
 * @description User not authenticated
 */
export const createBookmark401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Bookmark already exists
 */
export const createBookmark409Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const createBookmark422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const createBookmarkErrorSchema = z.lazy(() => apiErrorSchema)

export const createBookmarkMutationRequestSchema = z
  .lazy(() => bookmarkCreateSchema)
  .describe('Data to create a new bookmark')

export const createBookmarkMutationResponseSchema = z.lazy(
  () => createBookmark201Schema,
)

export const getBookmarkPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

export const getBookmarkQueryParamsSchema = z
  .object({
    withTags: z
      .boolean()
      .describe('Whether to include the tags linked to the bookmark')
      .optional(),
  })
  .optional()

/**
 * @description Bookmark by ID
 */
export const getBookmark200Schema = z
  .lazy(() => bookmarkDetailsSchema)
  .describe('Extended details of a bookmark')

/**
 * @description User not authenticated
 */
export const getBookmark401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const getBookmark403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Bookmark not found
 */
export const getBookmark404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const getBookmarkErrorSchema = z.lazy(() => apiErrorSchema)

export const getBookmarkQueryResponseSchema = z.lazy(() => getBookmark200Schema)

export const deleteBookmarkPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Successfully deleted bookmark
 */
export const deleteBookmark204Schema = z.any()

/**
 * @description User not authenticated
 */
export const deleteBookmark401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const deleteBookmark403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Bookmark not found
 */
export const deleteBookmark404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const deleteBookmarkErrorSchema = z.lazy(() => apiErrorSchema)

export const deleteBookmarkMutationResponseSchema = z.lazy(
  () => deleteBookmark204Schema,
)

export const updateBookmarkPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Updated bookmark
 */
export const updateBookmark200Schema = z
  .lazy(() => bookmarkSchema)
  .describe('Bookmark to a webpage')

/**
 * @description User not authenticated
 */
export const updateBookmark401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const updateBookmark403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Bookmark not found
 */
export const updateBookmark404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const updateBookmark422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const updateBookmarkErrorSchema = z.lazy(() => apiErrorSchema)

export const updateBookmarkMutationRequestSchema = z
  .lazy(() => bookmarkUpdateSchema)
  .describe('Updates to make to an existing bookmark')

export const updateBookmarkMutationResponseSchema = z.lazy(
  () => updateBookmark200Schema,
)

export const linkBookmarkTagsPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Successfully linked tags
 */
export const linkBookmarkTags204Schema = z.any()

/**
 * @description User not authenticated
 */
export const linkBookmarkTags401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const linkBookmarkTags403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Bookmark not found
 */
export const linkBookmarkTags404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const linkBookmarkTags422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const linkBookmarkTagsErrorSchema = z.lazy(() => apiErrorSchema)

export const linkBookmarkTagsMutationRequestSchema = z
  .lazy(() => linkBookmarkTagsSchema)
  .describe('Action to link tags to a bookmark')

export const linkBookmarkTagsMutationResponseSchema = z.lazy(
  () => linkBookmarkTags204Schema,
)

/**
 * @description Scraped bookmark
 */
export const scrapeBookmark201Schema = z
  .lazy(() => bookmarkScrapedSchema)
  .describe('Scraped bookmark')

/**
 * @description User not authenticated
 */
export const scrapeBookmark401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const scrapeBookmark422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Failed to fetch data
 */
export const scrapeBookmark502Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const scrapeBookmarkErrorSchema = z.lazy(() => apiErrorSchema)

export const scrapeBookmarkMutationRequestSchema = z
  .lazy(() => bookmarkScrapeSchema)
  .describe('Data to scrape a bookmark using')

export const scrapeBookmarkMutationResponseSchema = z.lazy(
  () => scrapeBookmark201Schema,
)

/**
 * @description Successfully started import
 */
export const importBookmarks204Schema = z.any()

/**
 * @description User not authenticated
 */
export const importBookmarks401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const importBookmarksErrorSchema = z.lazy(() => apiErrorSchema)

export const importBookmarksMutationRequestSchema = z.array(
  z.number().int().min(0),
)

export const importBookmarksMutationResponseSchema = z.lazy(
  () => importBookmarks204Schema,
)

/**
 * @description Netscape bookmarks file
 */
export const exportBookmarks200Schema = z.array(z.number().int().min(0))

/**
 * @description User not authenticated
 */
export const exportBookmarks401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const exportBookmarksErrorSchema = z.lazy(() => apiErrorSchema)

export const exportBookmarksMutationResponseSchema = z.lazy(
  () => exportBookmarks200Schema,
)

/**
 * @description Paginated list of collections
 */
export const listCollections200Schema = z
  .lazy(() => paginatedCollectionSchema)
  .describe('Paginated list of results')

/**
 * @description User not authenticated
 */
export const listCollections401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const listCollectionsErrorSchema = z.lazy(() => apiErrorSchema)

export const listCollectionsQueryResponseSchema = z.lazy(
  () => listCollections200Schema,
)

/**
 * @description Created collection
 */
export const createCollection201Schema = z.lazy(() => collectionSchema)

/**
 * @description User not authenticated
 */
export const createCollection401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Collection already exists
 */
export const createCollection409Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const createCollection422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const createCollectionErrorSchema = z.lazy(() => apiErrorSchema)

export const createCollectionMutationRequestSchema = z.lazy(
  () => collectionCreateSchema,
)

export const createCollectionMutationResponseSchema = z.lazy(
  () => createCollection201Schema,
)

export const getCollectionPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Collection by ID
 */
export const getCollection200Schema = z.lazy(() => collectionSchema)

/**
 * @description User not authenticated
 */
export const getCollection401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const getCollection403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Collection not found
 */
export const getCollection404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const getCollectionErrorSchema = z.lazy(() => apiErrorSchema)

export const getCollectionQueryResponseSchema = z.lazy(
  () => getCollection200Schema,
)

export const deleteCollectionPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Successfully deleted collection
 */
export const deleteCollection204Schema = z.any()

/**
 * @description User not authenticated
 */
export const deleteCollection401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const deleteCollection403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Collection not found
 */
export const deleteCollection404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const deleteCollectionErrorSchema = z.lazy(() => apiErrorSchema)

export const deleteCollectionMutationResponseSchema = z.lazy(
  () => deleteCollection204Schema,
)

export const updateCollectionPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Updated collection
 */
export const updateCollection200Schema = z.lazy(() => collectionSchema)

/**
 * @description User not authenticated
 */
export const updateCollection401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const updateCollection403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Collection not found
 */
export const updateCollection404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const updateCollection422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const updateCollectionErrorSchema = z.lazy(() => apiErrorSchema)

export const updateCollectionMutationRequestSchema = z.lazy(
  () => collectionUpdateSchema,
)

export const updateCollectionMutationResponseSchema = z.lazy(
  () => updateCollection200Schema,
)

/**
 * @description API config
 */
export const getConfig200Schema = z
  .lazy(() => configSchema)
  .describe('API config')

export const getConfigQueryResponseSchema = z.lazy(() => getConfig200Schema)

export const listFeedEntriesQueryParamsSchema = z
  .object({
    feedId: z
      .string()
      .uuid()
      .describe('Filter by the ID of the associated RSS feed')
      .optional(),
    cursor: z.string().describe('Pagination cursor').optional(),
  })
  .optional()

/**
 * @description Paginated list of feed entries
 */
export const listFeedEntries200Schema = z
  .lazy(() => paginatedFeedEntrySchema)
  .describe('Paginated list of results')

/**
 * @description User not authenticated
 */
export const listFeedEntries401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const listFeedEntriesErrorSchema = z.lazy(() => apiErrorSchema)

export const listFeedEntriesQueryResponseSchema = z.lazy(
  () => listFeedEntries200Schema,
)

export const getFeedEntryPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Feed entry by ID
 */
export const getFeedEntry200Schema = z
  .lazy(() => feedEntrySchema)
  .describe('RSS feed entry')

/**
 * @description User not authenticated
 */
export const getFeedEntry401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const getFeedEntry403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Feed entry not found
 */
export const getFeedEntry404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const getFeedEntryErrorSchema = z.lazy(() => apiErrorSchema)

export const getFeedEntryQueryResponseSchema = z.lazy(
  () => getFeedEntry200Schema,
)

/**
 * @description List of detected feeds
 */
export const detectFeeds201Schema = z.array(
  z.lazy(() => feedDetectedSchema).describe('Detected RSS feed'),
)

/**
 * @description User not authenticated
 */
export const detectFeeds401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const detectFeeds422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Failed to fetch data
 */
export const detectFeeds502Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const detectFeedsErrorSchema = z.lazy(() => apiErrorSchema)

export const detectFeedsMutationRequestSchema = z
  .lazy(() => feedDetectSchema)
  .describe('Data to detect RSS feeds using')

export const detectFeedsMutationResponseSchema = z.lazy(
  () => detectFeeds201Schema,
)

/**
 * @description Scraped feed
 */
export const scrapeFeed201Schema = z.lazy(() => feedSchema).describe('RSS feed')

/**
 * @description User not authenticated
 */
export const scrapeFeed401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const scrapeFeed422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Failed to fetch data
 */
export const scrapeFeed502Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const scrapeFeedErrorSchema = z.lazy(() => apiErrorSchema)

export const scrapeFeedMutationRequestSchema = z
  .lazy(() => feedScrapeSchema)
  .describe('Data to scrape an RSS feed using')

export const scrapeFeedMutationResponseSchema = z.lazy(
  () => scrapeFeed201Schema,
)

/**
 * @description Paginated list of streams
 */
export const listStreams200Schema = z
  .lazy(() => paginatedStreamSchema)
  .describe('Paginated list of results')

/**
 * @description User not authenticated
 */
export const listStreams401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const listStreamsErrorSchema = z.lazy(() => apiErrorSchema)

export const listStreamsQueryResponseSchema = z.lazy(() => listStreams200Schema)

/**
 * @description Created stream
 */
export const createStream201Schema = z.lazy(() => streamSchema)

/**
 * @description User not authenticated
 */
export const createStream401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Stream already exists
 */
export const createStream409Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const createStream422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const createStreamErrorSchema = z.lazy(() => apiErrorSchema)

export const createStreamMutationRequestSchema = z.lazy(
  () => streamCreateSchema,
)

export const createStreamMutationResponseSchema = z.lazy(
  () => createStream201Schema,
)

export const getStreamPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Stream by ID
 */
export const getStream200Schema = z.lazy(() => streamSchema)

/**
 * @description User not authenticated
 */
export const getStream401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const getStream403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Stream not found
 */
export const getStream404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const getStreamErrorSchema = z.lazy(() => apiErrorSchema)

export const getStreamQueryResponseSchema = z.lazy(() => getStream200Schema)

export const deleteStreamPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Successfully deleted stream
 */
export const deleteStream204Schema = z.any()

/**
 * @description User not authenticated
 */
export const deleteStream401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const deleteStream403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Stream not found
 */
export const deleteStream404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const deleteStreamErrorSchema = z.lazy(() => apiErrorSchema)

export const deleteStreamMutationResponseSchema = z.lazy(
  () => deleteStream204Schema,
)

export const updateStreamPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Updated stream
 */
export const updateStream200Schema = z.lazy(() => streamSchema)

/**
 * @description User not authenticated
 */
export const updateStream401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const updateStream403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Stream not found
 */
export const updateStream404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const updateStream422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const updateStreamErrorSchema = z.lazy(() => apiErrorSchema)

export const updateStreamMutationRequestSchema = z.lazy(
  () => streamUpdateSchema,
)

export const updateStreamMutationResponseSchema = z.lazy(
  () => updateStream200Schema,
)

export const listSubscriptionsQueryParamsSchema = z
  .object({
    filterByTags: z
      .boolean()
      .describe('Whether to filter by tags linked to the subscription')
      .optional(),
    'tag[]': z
      .array(z.string().uuid())
      .describe('Filter by the IDs of the tags linked to the subscription')
      .optional(),
    withFeed: z
      .boolean()
      .describe('Whether to include the feed associated with the subscription')
      .optional(),
    withUnreadCount: z
      .boolean()
      .describe(
        'Whether to include the count of the unread subscription entries associated with the subscription',
      )
      .optional(),
    withTags: z
      .boolean()
      .describe('Whether to include the tags linked to the subscription')
      .optional(),
  })
  .optional()

/**
 * @description Paginated list of subscriptions
 */
export const listSubscriptions200Schema = z
  .lazy(() => paginatedSubscriptionDetailsSchema)
  .describe('Paginated list of results')

/**
 * @description User not authenticated
 */
export const listSubscriptions401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const listSubscriptionsErrorSchema = z.lazy(() => apiErrorSchema)

export const listSubscriptionsQueryResponseSchema = z.lazy(
  () => listSubscriptions200Schema,
)

/**
 * @description Created subscription
 */
export const createSubscription201Schema = z
  .lazy(() => subscriptionSchema)
  .describe('User subscription to an RSS feed')

/**
 * @description User not authenticated
 */
export const createSubscription401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Subscription already exists
 */
export const createSubscription409Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const createSubscription422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const createSubscriptionErrorSchema = z.lazy(() => apiErrorSchema)

export const createSubscriptionMutationRequestSchema = z
  .lazy(() => subscriptionCreateSchema)
  .describe('Data to create a new user subscription')

export const createSubscriptionMutationResponseSchema = z.lazy(
  () => createSubscription201Schema,
)

export const getSubscriptionPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

export const getSubscriptionQueryParamsSchema = z
  .object({
    withFeed: z
      .boolean()
      .describe('Whether to include the feed associated with the subscription')
      .optional(),
    withUnreadCount: z
      .boolean()
      .describe(
        'Whether to include the count of the unread subscription entries associated with the subscription',
      )
      .optional(),
    withTags: z
      .boolean()
      .describe('Whether to include the tags linked to the subscription')
      .optional(),
  })
  .optional()

/**
 * @description Subscription by ID
 */
export const getSubscription200Schema = z
  .lazy(() => subscriptionDetailsSchema)
  .describe('Extended details of a user subscription')

/**
 * @description User not authenticated
 */
export const getSubscription401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const getSubscription403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Subscription not found
 */
export const getSubscription404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const getSubscriptionErrorSchema = z.lazy(() => apiErrorSchema)

export const getSubscriptionQueryResponseSchema = z.lazy(
  () => getSubscription200Schema,
)

export const deleteSubscriptionPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Successfully deleted subscription
 */
export const deleteSubscription204Schema = z.any()

/**
 * @description User not authenticated
 */
export const deleteSubscription401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const deleteSubscription403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Subscription not found
 */
export const deleteSubscription404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const deleteSubscriptionErrorSchema = z.lazy(() => apiErrorSchema)

export const deleteSubscriptionMutationResponseSchema = z.lazy(
  () => deleteSubscription204Schema,
)

export const updateSubscriptionPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Updated subscription
 */
export const updateSubscription200Schema = z
  .lazy(() => subscriptionSchema)
  .describe('User subscription to an RSS feed')

/**
 * @description User not authenticated
 */
export const updateSubscription401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const updateSubscription403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Subscription not found
 */
export const updateSubscription404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const updateSubscription422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const updateSubscriptionErrorSchema = z.lazy(() => apiErrorSchema)

export const updateSubscriptionMutationRequestSchema = z
  .lazy(() => subscriptionUpdateSchema)
  .describe('Updates to make to an existing subscription')

export const updateSubscriptionMutationResponseSchema = z.lazy(
  () => updateSubscription200Schema,
)

export const linkSubscriptionTagsPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Successfully linked tags
 */
export const linkSubscriptionTags204Schema = z.any()

/**
 * @description User not authenticated
 */
export const linkSubscriptionTags401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const linkSubscriptionTags403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Subscription not found
 */
export const linkSubscriptionTags404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const linkSubscriptionTags422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const linkSubscriptionTagsErrorSchema = z.lazy(() => apiErrorSchema)

export const linkSubscriptionTagsMutationRequestSchema = z
  .lazy(() => linkSubscriptionTagsSchema)
  .describe('Action to link tags to a user subscription')

export const linkSubscriptionTagsMutationResponseSchema = z.lazy(
  () => linkSubscriptionTags204Schema,
)

export const markSubscriptionEntryAsReadPathParamsSchema = z.object({
  sid: z
    .string()
    .uuid()
    .describe('Unique identifier of the associated subscription'),
  eid: z
    .string()
    .uuid()
    .describe('Unique identifier of the associated feed entry'),
})

/**
 * @description Updated subscription entry
 */
export const markSubscriptionEntryAsRead200Schema = z
  .lazy(() => subscriptionEntrySchema)
  .describe(
    'Association of a RSS feed entry to a user subscription. The pairing of subscription ID and feed entry ID is unique.',
  )

/**
 * @description User not authenticated
 */
export const markSubscriptionEntryAsRead401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const markSubscriptionEntryAsRead403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Subscription entry not found
 */
export const markSubscriptionEntryAsRead404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const markSubscriptionEntryAsRead422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const markSubscriptionEntryAsReadErrorSchema = z.lazy(
  () => apiErrorSchema,
)

export const markSubscriptionEntryAsReadMutationResponseSchema = z.lazy(
  () => markSubscriptionEntryAsRead200Schema,
)

export const markSubscriptionEntryAsUnreadPathParamsSchema = z.object({
  sid: z
    .string()
    .uuid()
    .describe('Unique identifier of the associated subscription'),
  eid: z
    .string()
    .uuid()
    .describe('Unique identifier of the associated feed entry'),
})

/**
 * @description Updated subscription entry
 */
export const markSubscriptionEntryAsUnread200Schema = z
  .lazy(() => subscriptionEntrySchema)
  .describe(
    'Association of a RSS feed entry to a user subscription. The pairing of subscription ID and feed entry ID is unique.',
  )

/**
 * @description User not authenticated
 */
export const markSubscriptionEntryAsUnread401Schema = z.lazy(
  () => apiErrorSchema,
)

/**
 * @description User not authorized
 */
export const markSubscriptionEntryAsUnread403Schema = z.lazy(
  () => apiErrorSchema,
)

/**
 * @description Subscription entry not found
 */
export const markSubscriptionEntryAsUnread404Schema = z.lazy(
  () => apiErrorSchema,
)

/**
 * @description Invalid input
 */
export const markSubscriptionEntryAsUnread422Schema = z.lazy(
  () => apiErrorSchema,
)

/**
 * @description Unknown error
 */
export const markSubscriptionEntryAsUnreadErrorSchema = z.lazy(
  () => apiErrorSchema,
)

export const markSubscriptionEntryAsUnreadMutationResponseSchema = z.lazy(
  () => markSubscriptionEntryAsUnread200Schema,
)

/**
 * @description Successfully started import
 */
export const importSubscriptions204Schema = z.any()

/**
 * @description User not authenticated
 */
export const importSubscriptions401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const importSubscriptionsErrorSchema = z.lazy(() => apiErrorSchema)

export const importSubscriptionsMutationRequestSchema = z.array(
  z.number().int().min(0),
)

export const importSubscriptionsMutationResponseSchema = z.lazy(
  () => importSubscriptions204Schema,
)

/**
 * @description OPML subscriptions file
 */
export const exportSubscriptions200Schema = z.array(z.number().int().min(0))

/**
 * @description User not authenticated
 */
export const exportSubscriptions401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const exportSubscriptionsErrorSchema = z.lazy(() => apiErrorSchema)

export const exportSubscriptionsMutationResponseSchema = z.lazy(
  () => exportSubscriptions200Schema,
)

export const listSubscriptionEntriesQueryParamsSchema = z
  .object({
    streamId: z
      .string()
      .uuid()
      .describe(
        'Filter by the ID of a stream whose filters may apply to the subscription entry',
      )
      .optional(),
    subscriptionId: z
      .string()
      .uuid()
      .describe('Filter by the ID of the associated subscription')
      .optional(),
    hasRead: z
      .boolean()
      .describe(
        'Filter by whether the subscription entry has been marked as read',
      )
      .optional(),
    'tag[]': z
      .array(z.string().uuid())
      .describe(
        'Filter by the IDs of the tags linked to the associated subscription',
      )
      .optional(),
    cursor: z
      .string()
      .describe('Pagination cursor from the previous set of results')
      .optional(),
  })
  .optional()

/**
 * @description Paginated list of subscription entries
 */
export const listSubscriptionEntries200Schema = z
  .lazy(() => paginatedSubscriptionEntryDetailsSchema)
  .describe('Paginated list of results')

/**
 * @description User not authenticated
 */
export const listSubscriptionEntries401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const listSubscriptionEntriesErrorSchema = z.lazy(() => apiErrorSchema)

export const listSubscriptionEntriesQueryResponseSchema = z.lazy(
  () => listSubscriptionEntries200Schema,
)

export const listTagsQueryParamsSchema = z
  .object({
    tagType: z
      .enum(['bookmarks', 'feeds'])
      .describe('Filter by the type of tag')
      .optional(),
    withSubscriptionCount: z
      .boolean()
      .describe(
        'Whether to include the count of subscriptions the tag is linked to',
      )
      .optional(),
    withBookmarkCount: z
      .boolean()
      .describe(
        'Whether to include the count of bookmarks the tag is linked to',
      )
      .optional(),
  })
  .optional()

/**
 * @description Paginated list of tags
 */
export const listTags200Schema = z
  .lazy(() => paginatedTagDetailsSchema)
  .describe('Paginated list of results')

/**
 * @description User not authenticated
 */
export const listTags401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const listTagsErrorSchema = z.lazy(() => apiErrorSchema)

export const listTagsQueryResponseSchema = z.lazy(() => listTags200Schema)

/**
 * @description Created tag
 */
export const createTag201Schema = z
  .lazy(() => tagSchema)
  .describe('Tag that can be attached to subscriptions and bookmarks')

/**
 * @description User not authenticated
 */
export const createTag401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Tag already exists
 */
export const createTag409Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const createTag422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const createTagErrorSchema = z.lazy(() => apiErrorSchema)

export const createTagMutationRequestSchema = z
  .lazy(() => tagCreateSchema)
  .describe('Data to create a new tag')

export const createTagMutationResponseSchema = z.lazy(() => createTag201Schema)

export const getTagPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

export const getTagQueryParamsSchema = z
  .object({
    withSubscriptionCount: z
      .boolean()
      .describe(
        'Whether to include the count of subscriptions the tag is linked to',
      )
      .optional(),
    withBookmarkCount: z
      .boolean()
      .describe(
        'Whether to include the count of bookmarks the tag is linked to',
      )
      .optional(),
  })
  .optional()

/**
 * @description Tag by ID
 */
export const getTag200Schema = z
  .lazy(() => tagDetailsSchema)
  .describe('Extended details of a tag')

/**
 * @description User not authenticated
 */
export const getTag401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const getTag403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Tag not found
 */
export const getTag404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const getTagErrorSchema = z.lazy(() => apiErrorSchema)

export const getTagQueryResponseSchema = z.lazy(() => getTag200Schema)

export const deleteTagPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Successfully deleted tag
 */
export const deleteTag204Schema = z.any()

/**
 * @description User not authenticated
 */
export const deleteTag401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const deleteTag403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Tag not found
 */
export const deleteTag404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const deleteTagErrorSchema = z.lazy(() => apiErrorSchema)

export const deleteTagMutationResponseSchema = z.lazy(() => deleteTag204Schema)

export const updateTagPathParamsSchema = z.object({
  id: z.string().uuid().describe('Unique identifier of the resource'),
})

/**
 * @description Updated tag
 */
export const updateTag200Schema = z
  .lazy(() => tagSchema)
  .describe('Tag that can be attached to subscriptions and bookmarks')

/**
 * @description User not authenticated
 */
export const updateTag401Schema = z.lazy(() => apiErrorSchema)

/**
 * @description User not authorized
 */
export const updateTag403Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Tag not found
 */
export const updateTag404Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Invalid input
 */
export const updateTag422Schema = z.lazy(() => apiErrorSchema)

/**
 * @description Unknown error
 */
export const updateTagErrorSchema = z.lazy(() => apiErrorSchema)

export const updateTagMutationRequestSchema = z
  .lazy(() => tagUpdateSchema)
  .describe('Updates to make to an existing tag')

export const updateTagMutationResponseSchema = z.lazy(() => updateTag200Schema)
